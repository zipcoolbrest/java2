1. Ќеобходимо написать два метода, которые делают следующее:
1) —оздают одномерный длинный массив, например:
static final int size = 10 000 000 ;
static final int h = size / 2 ;
float [] arr = new float [ size ].
2) «аполн€ют этот массив единицами.
3) «асекают врем€ выполнени€: long a = System.currentTimeMillis().
4) ѕроход€т по всему массиву и дл€ каждой €чейки считают новое значение по формуле:
arr [ i ] = ( float )( arr [ i ] * Math . sin ( 0.2f + i / 5 ) * Math . cos ( 0.2f + i / 5 ) *
Math . cos ( 0.4f + i / 2 )).
5) ѕровер€етс€ врем€ окончани€ метода System.currentTimeMillis().
6) ¬ консоль выводитс€ врем€ работы: System.out.println(System.currentTimeMillis() - a).
ќтличие первого метода от второго:
? ѕервый просто бежит по массиву и вычисл€ет значени€.
? ¬торой разбивает массив на два массива, в двух потоках высчитывает новые значени€ и
потом склеивает эти массивы обратно в один.
ѕример делени€ одного массива на два:
? System.arraycopy(arr, 0, a1, 0, h);
? System.arraycopy(arr, h, a2, 0, h).
ѕример обратной склейки:
? System.arraycopy(a1, 0, arr, 0, h);
? System.arraycopy(a2, 0, arr, h, h).
ѕримечание:
System.arraycopy() Ч копирует данные из одного массива в другой:
System.arraycopy(массив-источник, откуда начинаем брать данные из массива-источника,
массив-назначение, откуда начинаем записывать данные в массив-назначение, сколько €чеек
копируем)
ѕо замерам времени:
ƒл€ первого метода надо считать врем€ только на цикл расчета:
for ( int i = 0 ; i < size ; i ++) {
arr [ i ] = ( float )( arr [ i ] * Math . sin ( 0.2f + i / 5 ) * Math . cos ( 0.2f + i / 5 ) *
Math . cos ( 0.4f + i / 2 ));
}
ƒл€ второго метода замер€ете врем€ разбивки массива на 2, просчета каждого из двух массивов и
склейки.